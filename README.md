# linux_cross_thread_demo

[TOC]

## 前置知识

### Linux的IO

在Linux中，计算机IO（Input/Output）的抽象可以通过文件系统来实现。在Linux中，所有的设备都被视为文件，这包括硬盘、网络接口、串行端口、键盘等。这些设备都可以被当作文件来读取或写入数据。

文件系统的抽象可以使应用程序与底层设备隔离，这意味着应用程序可以使用相同的API（Application Programming
Interface）来读取和写入不同的设备。这种抽象也提供了一种安全机制，因为只有特定的权限才能访问某些设备文件。

此外，在Linux中，还有一些特殊的文件，如管道（pipe）、套接字（socket）和字符设备（character
device）等。这些文件也可以用来实现进程间通信（IPC）和网络通信等功能。

总的来说，Linux通过文件系统提供了一种通用的IO抽象，使得应用程序可以方便地与底层设备进行交互，并提供了一些特殊文件来支持更高级的功能。

### 事件驱动

事件驱动是一种编程范式，它基于事件的发生来触发代码执行。在事件驱动编程中，程序通过注册回调函数或事件处理程序来监听事件，当事件发生时，相应的回调函数或事件处理程序会被调用。

在事件驱动编程中，程序通常会维护一个事件循环（Event
Loop）。事件循环会不断地监听事件，当事件发生时，它会将事件传递给相应的回调函数或事件处理程序进行处理。在处理完事件后，程序会返回到事件循环，等待下一个事件的发生。

事件驱动编程常用于网络编程和图形用户界面（GUI）开发等场景中，因为这些场景中通常需要处理大量的事件。相对于传统的多线程或多进程编程模型，事件驱动编程可以更加高效地处理大量的并发请求，因为它可以避免线程或进程的切换开销，同时还可以充分利用CPU资源。

常见的事件驱动框架包括Node.js、Qt等。事件驱动编程在现代软件开发中扮演着越来越重要的角色，因为它可以使程序更加响应式和可伸缩。

### IO与事件驱动

IO（Input/Output）和事件驱动是密切相关的。在计算机系统中，IO操作通常是比较耗时的操作，因为它需要等待外部设备的响应。为了避免阻塞程序的运行，通常需要采用异步IO的方式来进行IO操作。

在异步IO的模型中，程序会向操作系统注册IO事件，当IO操作完成后，操作系统会通知程序相应的IO事件已经发生。这个过程涉及到事件的监听和处理，因此事件驱动模型非常适合异步IO的实现。

在事件驱动模型中，程序通常会使用事件循环来监听IO事件的发生，当IO事件发生时，事件循环会调用相应的回调函数或事件处理程序来处理IO事件。这样可以使程序在等待IO操作完成的同时，能够继续处理其他的任务，从而提高程序的性能和响应速度。

## 跨线程

跨线程（cross-thread）通常指的是在多线程编程中，一个线程与另一个线程之间进行的数据传输或函数调用。由于不同线程之间的数据和执行上下文是相互独立的，因此跨线程通信需要特殊的机制来保证数据的一致性和正确性。

在多线程编程中，跨线程通信可以通过共享内存、消息队列、管道、信号量等机制实现。例如，可以使用锁机制或原子操作来保证共享内存的互斥访问，从而避免多个线程同时修改同一块内存的问题。消息队列可以用于在不同线程之间传递数据和通知事件，可以避免线程之间的直接依赖和耦合。管道和信号量等机制也可以用于线程之间的通信和同步。

跨线程通信的实现需要考虑线程安全、同步和性能等方面的问题。例如：

1. 在使用共享内存进行跨线程通信时，需要保证数据的同步和互斥访问，避免数据的竞争和死锁等问题。

2. 在使用消息队列进行跨线程通信时，需要考虑消息的处理顺序、缓冲区大小等问题，避免消息堆积和处理延迟。

3. 在使用管道和信号量等机制时，需要考虑线程的阻塞和唤醒等问题，避免线程间的死锁和饥饿等问题。

因此，跨线程通信是多线程编程中一个重要的概念，需要结合具体的应用场景和需求进行设计和实现，以保证程序的正确性和高效性。

### 跨线程实现

1. 线程池模式：线程池模式可以将多个任务分配给一组线程池中的线程来并发执行。这种模式可以减少线程的创建和销毁开销，提高程序的性能和响应能力。
2. 生产者-消费者模式：生产者-消费者模式可以将任务的生产和消费过程分离开来，通过一个任务队列来协调不同的线程之间的工作。这种模式可以避免不同线程之间的互锁和竞争，提高程序的并发度。
3. Future/Promise模式：Future/Promise模式可以将异步任务的执行和结果的获取分离开来，通过一个Future对象来表示异步任务的结果，通过一个Promise对象来实现异步任务的执行。这种模式可以很好地支持异步编程，提高程序的并发度和响应能力。
4. Actor模式：Actor模式将一个程序中的每个组件都看作是一个独立的Actor，每个Actor都有自己的状态和行为，它们通过消息进行交互和通信。这种模式可以很好地支持并发编程，提高程序的可伸缩性和并发度。
5. MapReduce模式：MapReduce模式是一种分布式计算模式，它将一个大任务分解成多个小任务，在多个计算节点上并行执行，然后将结果合并起来。这种模式可以很好地支持分布式计算，提高程序的性能和可扩展性。
6. 观察者模式：该模式下，一个对象维护多个观察者，当该对象发生变化时会通知所有观察者进行相应的处理。该模式适用于多个线程需要观察同一个对象状态的场景。
7. 管道-过滤器模式：该模式下，多个线程形成一个流水线，每个线程充当一个过滤器，线程之间通过管道进行数据传递。每个线程都可以独立地处理数据，数据会依次经过每个过滤器进行处理。这种模式适用于多个处理步骤且处理步骤之间可以并行执行的场景。
8. io_uring实现：下方详解。

## io_uring

io_uring是Linux内核提供的一种高效的异步IO框架，可以在用户空间和内核空间之间实现零拷贝、无锁化的数据传输和处理，从而提高IO操作的效率和吞吐量。io_uring的设计灵感来自于多个异步IO框架，如libaio、epoll、Windows IOCP等，但它在性能和功能方面都有所改进和增强。

io_uring的核心是一个称为"ring buffer"的环形缓冲区，它可以用于在用户空间和内核空间之间传递IO请求和IO完成事件。程序可以使用io_uring提供的接口向ring buffer中添加IO请求，并通过等待IO完成事件来处理IO操作的结果。由于IO请求和IO完成事件可以在同一个ring buffer中处理，因此可以避免在用户空间和内核空间之间频繁切换的开销，从而提高IO操作的效率。

io_uring还支持多种IO操作类型，如读、写、send、recv、accept、connect等，以及支持用户定义的操作类型。它还提供了多种IO操作的选项和参数，如超时时间、缓冲区大小、文件描述符等，可以满足不同场景下的需求。

io_uring 的主要功能包括：

1. 异步 I/O：io_uring 提供了一种高效的异步 I/O 操作方式，可以在用户态发起 I/O 请求，在内核态完成 I/O 操作。相比传统的 epoll
   等机制，可以避免不必要的上下文切换和数据复制，从而提高 I/O 操作的效率。

2. 文件读写：io_uring 支持文件的读写操作，可以在多个文件之间切换，从而避免了传统 I/O 操作中需要在每次读写之前进行文件描述符的切换。

3. 网络操作：io_uring 支持网络操作，可以通过 io_uring 实现高效的 TCP/UDP 套接字 I/O 操作，同时支持传输层协议的扩展（如
   TLS，QUIC 等）。

4. 事件通知：io_uring 支持事件通知机制，可以在 I/O 完成时通知用户态应用程序，从而避免了轮询操作和无用的系统调用。

5. 资源管理：io_uring 支持资源管理，可以在内核中为每个用户态 I/O 请求分配一个固定大小的环形缓冲区，从而避免了内存泄漏和资源浪费。

6. 并发处理：io_uring 可以在多个线程之间共享 I/O 请求队列，从而实现高并发的 I/O 操作，提高系统的吞吐量和响应能力。

uring模式可以很好地支持跨线程，主要有以下几个原因：

1. 基于事件驱动的设计：uring模式采用基于事件驱动的异步I/O机制，可以避免在I/O操作时线程的阻塞，从而提高程序的并发度和响应能力。同时，由于事件是由内核通知应用程序的，所以可以很方便地跨线程处理不同的事件。
2. 无锁设计：uring模式采用无锁的设计方式，可以避免线程之间的互锁和竞争，提高程序的并发度和性能。因此，不同的线程可以通过uring共享同一个I/O环，实现高效的跨线程通信和协作。
3. 内存映射技术：uring模式支持内存映射技术，可以将磁盘上的数据映射到内存中，从而实现高效的文件读写操作。在多线程编程中，多个线程可以共享同一个内存映射区域，实现高效的跨线程共享。

综上所述，uring模式可以很好地支持跨线程，具有高效、高并发和高性能的优势。同时，由于其与epoll等传统的I/O机制不同，也可以避免传统I/O机制中存在的锁竞争和线程阻塞等问题，更适合于高并发的场景。

### uring对象

在io_uring中，可以添加以下对象：

1. 文件描述符（file descriptor）：这是io_uring最常见的对象之一。应用程序可以将一个或多个文件描述符添加到io_uring中，以执行异步读取和写入操作。

2. 缓冲区（buffer）：io_uring允许应用程序将缓冲区添加到io_uring中，以在内核中执行零拷贝操作。

3. 用户数据（user data）：应用程序可以将任意的用户数据添加到io_uring中，以在I/O操作完成后接收通知。

4. 事件（event）：io_uring支持在内核中注册事件，并在事件触发时通知应用程序。这些事件可以是文件描述符上的I/O事件，也可以是定时器事件等。

5. 定时器（timer）：io_uring允许应用程序创建和管理定时器，以便在指定的时间间隔内执行某些操作。

6. NOP（no operation）：NOP是io_uring的特殊对象之一，它可以用于占位符或其他用途。

### uring机制

在 io_uring 中，有三个重要的概念：uring、sqe、cqe。

- uring：是一个内核和用户空间之间共享的环形缓冲区（ring buffer）。应用程序通过将操作添加到 uring 中来发起异步 I/O 请求，内核通过遍历
  uring 来处理这些请求。

- sqe：是提交队列元素（Submission Queue Entry）的缩写。它是应用程序向内核提交 I/O 请求的数据结构，包含了要执行的 I/O
  操作的各种参数，例如文件描述符、缓冲区地址、操作类型等。

- cqe：是完成队列元素（Completion Queue Entry）的缩写。它是内核向应用程序返回已完成的 I/O 请求的数据结构，包含了完成的 I/O
  操作的状态信息，例如传输的字节数、错误码等。

应用程序通过向提交队列中添加 sqe 来提交 I/O 请求，而内核则通过向完成队列中添加 cqe 来通知应用程序已完成的 I/O 请求的状态信息。

提交队列和完成队列都是由一组描述符组成的环形缓冲区，每个描述符对应一个 sqe 或 cqe。当应用程序向提交队列中添加 sqe 时，它会将
sqe 的描述符添加到提交队列的尾部，并将提交队列的 tail 指针向前移动。内核在遍历提交队列时会检查 tail 和 head
指针的位置，如果它们不相等，则说明有新的 sqe 等待处理。

当内核完成一个 I/O 操作时，它会将对应的 cqe 描述符添加到完成队列的尾部，并将完成队列的 tail
指针向前移动。应用程序可以轮询完成队列，以获取已完成的操作的状态信息，并处理这些信息。

因此，sqe 和 cqe 都是通过描述符的方式存放在 uring 中的，并且提交队列和完成队列都是由描述符组成的环形缓冲区，应用程序和内核都可以通过
tail 和 head 指针来管理它们。
sqe 和 cqe 是 uring 中最重要的数据结构之一，它们提供了一个通用的接口，使得应用程序可以使用一组简单的系统调用来执行高效的异步
I/O 操作。而 uring 则提供了一个高效的方式来提交和处理这些操作，减少了系统调用的开销，并允许应用程序在多个 I/O
操作之间共享缓冲区，从而实现了零拷贝的 I/O 操作。

### sqe和cqe大小

在使用 io_uring 时，提交队列和完成队列的大小可以是不同的。这是因为它们的作用不同，提交队列用于向内核提交 I/O
请求，而完成队列用于接收内核完成请求的通知。因此，提交队列的大小取决于应用程序提交 I/O
请求的频率和数量，而完成队列的大小则取决于内核完成请求的速度和应用程序处理完成事件的速度。

通常情况下，建议提交队列和完成队列的大小设置成相同的，这样可以避免提交队列和完成队列之间出现瓶颈。但在某些情况下，可以根据具体的应用场景进行调整。例如，如果应用程序的
I/O 请求较少，但响应时间较长，则可以增加完成队列的大小，以便更快地接收完成通知。反之，如果应用程序的 I/O
请求较多，可以增加提交队列的大小，以便更快地向内核提交请求。

### 结构体

#### io_uring

`io_uring` 结构体是 `liburing` 库中最重要的数据结构之一，它是一个指向异步 I/O 环的指针，同时包含了异步 I/O 环的相关属性和配置信息。

其中比较重要的成员变量有：

- `ring_fd`: 异步 I/O 环的文件描述符。
- `ring_entries`: 环中的总项数（也就是队列的深度）。
- `sq_entries`: 发送队列中的项数。
- `cq_entries`: 完成队列中的项数。
- `sq_head` 和 `sq_tail`: 发送队列中的头和尾指针。
- `cq_head` 和 `cq_tail`: 完成队列中的头和尾指针。
- `sqes`: 发送队列元素的数组，每个元素为 `io_uring_sqe` 结构体类型。
- `cqes`: 完成队列元素的数组，每个元素为 `io_uring_cqe` 结构体类型。
- `flags`: 环的配置标志位。
- `params`: 异步 I/O 环的参数结构体，包含了环的各种配置参数，如队列大小、线程 CPU 绑定等。

#### io_uring_sqe

`io_uring_sqe` 结构体是 `liburing` 库中用来描述异步 I/O 请求的数据结构，它包含了所有异步 I/O 请求所需要的参数。

其中比较重要的成员变量有：

- `opcode`: 操作码，指定了本次 I/O 请求的操作类型，如读取、写入、accept 等。
- `flags`: 标志位，指定了本次请求的一些属性，如是否需要 RWF_NOWAIT、是否需要 ATOMIC_CMPXCHG 等。
- `ioprio`: I/O 优先级。
- `fd`: 文件描述符。
- `off` 和 `addr`: 用于指定文件偏移和缓冲区地址。
- `len`: 指定缓冲区的长度。
- `rw_flags`：读写标志位，指定了读写操作的属性，如是否为非阻塞读写等。
- `user_data`: 用户数据，用于在异步 I/O 请求的开始和结束时传递额外的数据。
- `buf_index`：当使用固定缓冲区时，指定缓冲区在固定缓冲区数组中的索引。
- `personality`：个性化标志，用于特殊的操作类型。
- `splice_off_in` 和 `splice_off_out`：用于 splice 操作的偏移量。
- `pad2`：用于填充对齐的空间。

#### io_uring_cqe

io_uring_cqe（completion queue entry）结构体是liburing中用于表示完成队列条目的结构体。io_uring_cqe 结构体中的一些重要成员变量包括：

- `user_data`：该请求的用户数据，即在提交请求时使用 io_uring_sqe_set_data() 方法设置的数据。
- `res`：请求操作的结果，即返回的错误码或者读/写的字节数。
- `flags`：标志位，表示请求操作的类型以及是否发生错误等信息。
- `__pad2`：一个占位符，用于保持结构体大小的一致性。

其中，__pad2 不应该被程序员直接访问。

在使用 io_uring_cqe_get_data() 方法获取 user_data 成员变量的值时，程序员可以通过调用 io_uring_cqe_get_data() 方法获取该值。

同样，在使用完 io_uring_cqe 结构体后，需要调用 io_uring_cqe_seen() 方法告诉 liburing 已经处理完该请求，以便该请求可以被下一次提交的请求使用。

### 方法

#### io_uring_queue_init()

io_uring_queue_init()函数是I/O uring库中的一个初始化函数，用于初始化一个io_uring对象。它的输入参数包括：

1. entries：指定I/O uring的队列大小。

2. ring：io_uring对象指针，用于存储初始化后的io_uring实例。

3. flags：可选参数，用于指定I/O uring的行为。

它的返回值为0表示初始化成功，否则表示初始化失败。在函数调用成功后，io_uring对象被初始化，并可以用于提交I/O请求。io_uring对象是一个环形队列，通过它可以在用户空间中管理和提交异步I/O操作。

io_uring_queue_init()
函数的输出参数是io_uring结构体类型的指针，指向一个初始化后的io_uring实例，该实例包含了io_uring的所有状态信息和队列信息。我们可以在程序中使用这个io_uring对象提交异步I/O请求，同时也可以通过它来控制和管理异步I/O操作的状态。

---

flags参数是一个位掩码，可以用于设置以下行为：

- `IORING_SETUP_IOPOLL`：当这个标志被设置时，io_uring将使用内核事件轮询机制(epoll)
  来监视I/O事件，而不是使用经典的I/O多路复用模型（如select/poll）。这个标志可以提高I/O吞吐量和响应速度，但只适用于Linux
  5.4及以上版本。

- `IORING_SETUP_SQPOLL`：当这个标志被设置时，io_uring将使用内核事件轮询机制来监视完成队列事件，而不是等待完成事件时使用轮询或者信号。这个标志可以减少轮询或信号机制带来的性能损失，但只适用于Linux
  5.11及以上版本。

- `IORING_SETUP_SQ_AFF`：当这个标志被设置时，io_uring将为提交请求的线程分配一个特定的CPU核心来执行请求，以提高I/O处理性能。

- `IORING_SETUP_CQSIZE`：用于指定完成队列的大小（即等待处理的完成事件数量），可以通过适当设置完成队列的大小来优化应用程序的I/O性能。
  需要注意的是，不同版本的I/O uring库可能支持不同的flags标志，使用时需要查看对应的API文档来确定支持哪些标志。

#### io_uring_get_sqe()

io_uring_get_sqe()函数用于获取I/O请求提交队列中的一个新项，以便我们可以对该项设置I/O操作的相关参数，并将其提交给内核处理。

io_uring_get_sqe()函数的输入参数为一个io_uring结构体类型的指针，表示I/O请求提交队列所在的io_uring对象。

函数没有输出参数，而是返回一个io_uring_sqe结构体类型的指针，该结构体表示一个I/O请求队列项，其中包含了I/O请求的相关参数。

通过设置io_uring_sqe结构体的各个字段可以指定异步I/O操作的相关参数，例如文件描述符、I/O类型、I/O缓冲区地址、I/O长度等等。设置完成后，可以使用io_uring_submit()
函数将这个请求项提交给内核处理，内核会在异步方式下执行这个I/O请求，同时将请求结果存储到io_uring对象的完成队列中。通过这种方式，我们可以以异步、非阻塞的方式提交和处理I/O请求，提高I/O吞吐量和系统的响应速度。

#### io_uring_prep_read()

io_uring_prep_read()函数用于初始化io_uring_sqe结构体，以便将读取文件操作提交给I/O请求队列，表示我们要从一个文件中读取数据。

io_uring_prep_read()函数的输入参数包括：

- `sqe`：io_uring_sqe结构体的指针，表示一个I/O请求队列项。

- `fd`：文件描述符，表示要读取的文件。

- `buf`：一个指向要读取数据的缓冲区的指针。

- `nbytes`：表示要读取的数据的字节数。

- `offset`：偏移量

io_uring_prep_read()函数返回0表示成功，否则表示出错。

调用io_uring_prep_read()函数会自动填充io_uring_sqe结构体中的各个字段，以便表示一个读取文件的I/O操作。这些字段包括：

- `opcode`：表示I/O操作类型，这里是读取文件操作。

- `flags`：用于指定I/O操作的一些属性，如O_DIRECT、O_SYNC等。

- `ioprio`：指定I/O操作的优先级和调度策略。

- `fd`：表示要读取的文件的文件描述符。

- `off`：表示从文件中的哪个位置开始读取数据。

- `addr`：一个指向要读取数据的缓冲区的指针。

- `len`：表示要读取的数据的字节数。

调用io_uring_prep_read()函数可以使得我们更方便地进行异步I/O操作，避免了手动填充io_uring_sqe结构体的过程，提高了代码的可读性和易用性。

#### io_uring_prep_write()

`io_uring_prep_write()`是一个iouring API函数，用于在指定文件描述符上准备一个写操作的sqe（submission queue entry）。

函数的输入参数包括：

- `sqe`：需要进行写操作的`io_uring_sqe`结构体指针。
- `fd`：需要进行写操作的文件描述符。
- `buf`：写入数据的缓冲区指针。
- `len`：写入数据的长度。
- `offset`：写入数据的偏移量。

函数的返回值为0表示操作成功，否则表示操作失败。

该函数的作用是准备一个写操作的sqe，将其添加到提交队列中，并在等待队列上注册一个等待事件。当操作完成时，将通过io_uring_wait()函数返回。

需要注意的是，该函数准备的写操作是异步的，当它返回时，并不意味着写操作已经完成。需要等到CQE（Completion Queue Entry）中的`res`字段值为写入数据的字节数时，才能确定写操作已经完成。

#### io_uring_sqe_set_flags()

io_uring_sqe_set_flags()
函数用于设置I/O请求队列项的flags字段，用于指定I/O请求的一些属性。这个函数可以让我们在调用io_uring_prep_*()
函数生成I/O请求队列项后，进一步调整I/O请求队列项的属性。

io_uring_sqe_set_flags()函数的输入参数包括：

- `sqe`：io_uring_sqe结构体的指针，表示一个I/O请求队列项。

- `flags`：表示要设置的I/O请求的属性，可以使用各种宏定义来设置，如：IORING_F_SYNC、IORING_F_NONBLOCK、IORING_F_DRAIN等等。

io_uring_sqe_set_flags()函数没有输出，它只是将I/O请求队列项的flags字段设置为指定的值。

使用io_uring_sqe_set_flags()函数可以在io_uring_prep_*()
函数生成I/O请求队列项后，对I/O请求队列项的flags字段进行进一步调整，以满足我们的特定需求。例如，可以设置IORING_F_NONBLOCK标志来使得I/O请求以非阻塞方式执行，也可以设置IORING_F_SYNC标志来使得I/O请求同步执行等等。通过设置不同的标志，我们可以灵活地控制I/O请求的属性和行为，以便满足不同的应用场景。

#### io_uring_submit()

io_uring_submit()函数用于提交I/O请求到内核的I/O请求队列中，以等待被内核处理。该函数的输入参数是指向io_uring结构体的指针，它代表一个I/O请求队列。该函数没有返回值。

当所有I/O请求队列项都被填充好之后，调用io_uring_submit()函数，会将所有的I/O请求提交到内核中等待处理。

在io_uring_submit()函数调用后，内核会开始处理提交的I/O请求。内核将按照I/O请求队列中请求的顺序，依次处理每个I/O请求。当请求完成后，内核将会将I/O完成事件推送到完成队列中。

此外，io_uring_submit()函数还会返回成功提交的I/O请求个数，如果返回的结果与我们期望的I/O请求个数不一致，那么可能是因为I/O请求队列已满，无法提交更多的I/O请求，或者因为发生了错误，导致I/O请求提交失败。

#### io_uring_wait_cqe()

io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr);

io_uring_wait_cqe() 函数用于等待完成队列事件，即等待操作完成后的通知。它会一直阻塞直到有一个完成的事件被放入到完成队列中。

该函数的输入参数为 io_uring 结构体指针，表示 I/O uring 实例，而输出参数为 io_uring_cqe 结构体指针，表示完成队列事件。

其中，ring 参数表示 I/O uring 实例，cqe_ptr 表示完成队列事件的指针。在函数调用成功时，cqe_ptr 指向的指针会被赋值为一个指向完成队列事件的指针。

该函数的返回值为 0 表示等待成功，否则返回错误码。

#### io_uring_sqe_set_data()

void io_uring_sqe_set_data(struct io_uring_sqe *sqe, void *data);

io_uring_sqe_set_data() 函数用于设置 I/O 请求的数据指针（也称为 "用户数据" 或 "上下文数据"）。这个指针可以被传递给应用程序的回调函数，以帮助应用程序区分和处理多个 I/O 请求的完成事件。

该函数接受两个参数：

- sqe：指向 io_uring_sqe 结构体的指针，用于设置其数据指针字段。

- data：一个指针，指向 I/O 请求的数据（或上下文数据）。

该函数没有返回值。

当 I/O 请求完成时，内核将在与 io_uring_wait_cqe() 或 io_uring_peek_cqe() 相关的结构体中设置 cqe->user_data 字段，以指向相应 I/O 请求的数据指针。应用程序可以使用 io_uring_cqe_get_data() 函数获取该指针，然后在回调函数中使用该指针进行处理。

例如，可以使用 io_uring_sqe_set_data() 将缓冲区指针传递给 I/O 请求，然后在 I/O 请求完成时使用 io_uring_cqe_get_data() 将其获取，并使用该指针读取或处理 I/O 完成事件。

#### io_uring_cqe_get_data()

void *io_uring_cqe_get_data(const struct io_uring_cqe *cqe);

io_uring_cqe_get_data() 函数用于获取已完成 I/O 请求的用户数据指针（也称为 "上下文数据" 或 "用户数据"）。该指针是通过 io_uring_sqe_set_data() 函数设置的，以帮助应用程序区分和处理多个 I/O 请求的完成事件。

该函数接受一个参数：

- cqe：指向 io_uring_cqe 结构体的指针，该结构体包含已完成 I/O 请求的元数据。

该函数**返回一个指向用户数据的指针**，应用程序可以在回调函数中使用该指针来处理已完成的 I/O 请求。

例如，可以使用 io_uring_sqe_set_data() 函数将缓冲区指针传递给 I/O 请求，然后在 I/O 请求完成时使用 io_uring_cqe_get_data() 函数将其获取，并使用该指针读取或处理 I/O 完成事件。

需要注意的是，只有当 I/O 请求完成后才能调用 io_uring_cqe_get_data() 函数，因为只有在这种情况下，内核才会在 io_uring_cqe 结构体中设置相应的用户数据指针。

#### io_uring_cqe_seen()

void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe);

io_uring_cqe_seen() 函数用于将 I/O 完成事件标记为已处理。当应用程序从 io_uring_wait_cqe() 或 io_uring_peek_cqe() 等函数中读取 io_uring_cqe 结构体时，该结构体会包含一个指向 I/O 请求的用户数据的指针。当应用程序处理完该 I/O 请求时，可以使用 io_uring_cqe_seen() 函数将其标记为已处理。

该函数接受两个参数：

- ring：指向 io_uring 结构体的指针，表示 I/O 完成队列。
- cqe：指向 io_uring_cqe 结构体的指针，表示已处理完的 I/O 请求。

该函数没有返回值。

应用程序需要在处理完每个 I/O 请求后调用 io_uring_cqe_seen() 函数来将其标记为已处理，以便内核可以将该 I/O 请求的缓冲区重用于新的 I/O 请求。未处理的 I/O 请求可能会导致缓冲区资源的耗尽，并使应用程序无法执行更多的 I/O 请求。

需要注意的是，在多线程环境中，需要保证每个线程只能处理它自己的 I/O 请求，并将每个 I/O 请求标记为已处理，否则可能导致数据损坏或死锁。

### 演示代码

#### test01.c

test01代码有两个读io，两个io循环会读取同一个文件，并且打印读到的内容

1. 首先创建一个 `io_uring` 对象，该对象表示 I/O 完成队列。
2. 创建两个缓冲区 `buf1` 和 `buf2`，每个缓冲区的大小为 `BUF_SIZE` 字节。
3. 调用 `io_uring_prep_read()` 函数向 `io_uring` 对象中添加一个读取文件的 I/O 请求。
4. 调用 `io_uring_submit()` 函数提交 I/O 请求。
5. 调用 `io_uring_wait_cqe()` 函数等待 I/O 请求完成事件。
6. 调用 `io_uring_cqe_get_data()` 函数获取已完成的 I/O 请求的用户数据。
7. 调用 `io_uring_cqe_seen()` 函数将已完成的 I/O 请求标记为已处理。

#### test02.c

test02代码使用了 io_uring_prep_write() 函数进行写操作。

第一个 io 使用 buf1 进行写操作，写入文件的偏移量为 0;

第二个 io 使用 buf2 进行写操作，写入文件的偏移量为 BLOCK_SIZE。

在每个 io 的提交中，使用 io_uring_sqe_set_data() 方法将对应的 buf 与该请求绑定。

在处理完成队列时，使用 io_uring_cqe_get_data() 方法获取对应的 buf，并进行输出。

## epoll机制

epoll是Linux内核提供的一种IO事件通知机制，可以用于高效地处理大量的并发IO事件。与传统的select和poll机制相比，epoll具有更高的效率和更好的扩展性。

在epoll的设计中，程序可以向内核注册多个文件描述符，并指定它们的IO事件类型（如读事件、写事件等）。当某个文件描述符上发生了指定的IO事件时，内核会通知程序相应的事件已经发生，程序可以采取相应的措施来处理这些事件。

在epoll机制中，程序可以将文件描述符设置为非阻塞模式，并向内核注册相应的IO事件。当IO事件发生时，内核会将该事件加入到epoll
fd的事件队列中，并通知程序相应的事件已经发生。程序可以通过调用epoll_wait函数来等待事件的发生，并处理事件。由于epoll_wait函数是一个阻塞调用，因此程序不需要轮询文件描述符，可以在等待IO事件的同时处理其他任务，从而实现异步IO操作。

epoll机制是实现异步IO的关键之一，可以提供高效的IO事件通知机制，从而实现异步IO操作。通过将epoll机制与其他异步IO技术（如非阻塞IO和线程池等）结合使用，可以实现高效的异步IO编程。

epoll机制具有以下优点：

1. 相对于传统的select和poll机制，epoll机制可以处理更多的并发IO事件。

2. epoll机制采用基于事件驱动的模式，可以避免不必要的轮询操作，从而提高IO操作的效率。

3. epoll机制支持边缘触发和水平触发两种模式，可以根据需要选择不同的触发模式。

4. epoll机制具有更好的扩展性和更少的内存开销，可以处理大量的文件描述符。

因此，epoll是一种高效的IO事件通知机制，广泛应用于网络编程、操作系统和服务器等领域。